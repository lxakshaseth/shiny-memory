<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Breakout: Invaders Hybrid — Final Version</title>
  <style>
    :root{
      --bg:#0b1020; --accent:#ffce00; --paddle:#66ddff; --enemy:#ff6b6b; --brick:#7cffb2; --text:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;transition:background .5s ease}
    .wrap{display:grid;place-items:center;height:100%;padding:20px;box-sizing:border-box}
    .card{width:960px;max-width:100%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(2,6,23,0.7)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    h1{color:var(--text);font-size:18px;margin:0}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600;transition:transform .2s ease}
    button:hover{transform:translateY(-2px)}
    .game-wrap{display:flex;gap:12px}
    canvas{border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:block}
    .sidebar{width:260px;min-width:220px;padding:12px;border-left:1px dashed rgba(255,255,255,0.03)}
    .stat{color:var(--text);font-size:14px;margin-bottom:8px}
    .big{font-size:20px;font-weight:700;color:var(--accent)}
    .hint{color:rgba(230,238,248,0.6);font-size:13px}
    @media (max-width:880px){.card{padding:8px}.game-wrap{flex-direction:column}.sidebar{width:100%;border-left:0;border-top:1px dashed rgba(255,255,255,0.03)}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>Breakout — Invaders Hybrid</h1>
        <div class="controls"><button id="startBtn">Start</button><button id="pauseBtn">Pause</button><button id="resetBtn">Reset</button></div>
      </header>
      <div class="game-wrap">
        <canvas id="game" width="720" height="520"></canvas>
        <aside class="sidebar">
          <div class="stat">Score<br><div class="big" id="score">0</div></div>
          <div class="stat">Lives<br><div class="big" id="lives">3</div></div>
          <div class="stat">Level<br><div class="big" id="level">1</div></div>
          <div class="stat">Balls<br><div class="big" id="balls">1</div></div>
          <hr style="opacity:.06;margin:10px 0">
          <div class="hint"><strong>Controls:</strong><br>← / → to move<br>Space to launch<br>X to fire</div>
        </aside>
      </div>
    </div>
  </div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let frames = 0;

  // UI elements
  const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives'), levelEl = document.getElementById('level'), ballsEl = document.getElementById('balls');
  const startBtn = document.getElementById('startBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');

  // Game state
  let state = { running:false, paused:false, score:0, lives:3, level:1, balls:1 };

  // Level-specific settings
  let levelSettings = {};

  // Key input
  const keys = {};
  window.addEventListener('keydown', e=>{keys[e.key]=true; if(e.key===' '){e.preventDefault();}});
  window.addEventListener('keyup', e=>{keys[e.key]=false});

  // Utility
  function rand(min,max){return Math.random()*(max-min)+min}

  // Sounds
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq, duration=0.06, type='sine', gain=0.08){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + duration);
  }

  // Particle system
  const particles = [];
  function spawnParticles(x,y,color,count=18){ for(let i=0;i<count;i++) particles.push({x,y,vx:rand(-3,3),vy:rand(-4,-0.3),life:rand(30,80),color}); }
  function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.12;p.life--;p.vx*=0.99;p.vy*=0.99;if(p.life<=0)particles.splice(i,1);} }
  function drawParticles(){ for(const p of particles){ ctx.globalAlpha=Math.max(0,p.life/80);ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,2,2);} ctx.globalAlpha=1;}

  // Game Objects
  const paddle = { w:120, h:14, x:(W-120)/2, y:H-44, speed:8, color:'#66ddff', cooldown:0, shield:3, maxShield:3, invincibleTimer:0 };
  let balls = [], bricks = [], powerUps = [], coins = [], enemyBullets = [], playerBullets = [];

  function spawnBall(x,y,dx,dy){ balls.push({x,y,dx,dy,r:8,stuck:true}); }
  function spawnPowerUp(x, y, type) { powerUps.push({x,y,type,w:18,h:18,vy:2}); } // Increased size
  function spawnCoin(x, y) { coins.push({x,y,r:8,vy:2.5}); } // Increased size

  // New Level System
  function createLevel(level){
    bricks = [];
    paddle.w = 120; // Reset paddle width each level

    levelSettings = { bgColor: '#071026', enemySpeedMultiplier: 1.0, enemyFireRate: 0.009, enemyBulletSpeed: 2.5, brickHealthMultiplier: 1.0 };

    if (level >= 4 && level <= 6) {
        levelSettings.bgColor = '#200726'; levelSettings.enemyFireRate = 0.011; levelSettings.enemyBulletSpeed = 3.0;
    } else if (level >= 7) {
        levelSettings.bgColor = '#260707'; levelSettings.enemyFireRate = 0.014; levelSettings.enemyBulletSpeed = 3.5; levelSettings.brickHealthMultiplier = 1.5;
    }
    document.body.style.background = `radial-gradient(circle at 10% 10%, ${levelSettings.bgColor} 0%, var(--bg) 40%)`;

    const rows = 4 + Math.min(6, level);
    const cols = 9;
    const margin = 40; const bw = (W - margin*2 - (cols-1)*8)/cols; const bh = 18;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        let health = 1 + Math.floor(level/3);
        if (level >= 7 && r < 2) { health = Math.ceil((2 + Math.floor(level/2)) * levelSettings.brickHealthMultiplier); }
        bricks.push({x:margin+c*(bw+8), y:60+r*(bh+8), w:bw, h:bh, health, maxHealth: health, vx:0.5+level*0.08, dir:(r%2?1:-1), cooldown:rand(60,240)});
      }
    }
  }

  function rectIntersect(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;}

  function reset(full=false){
    if(full){ state.score=0; state.lives=3; state.level=1; }
    state.balls = 1;
    paddle.x = (W - paddle.w)/2;
    paddle.shield = paddle.maxShield;
    paddle.invincibleTimer = 0;
    balls = [], enemyBullets = [], playerBullets = [], powerUps = [], coins = [];
    createLevel(state.level);
    spawnBall(paddle.x + paddle.w/2, paddle.y - 12, 0, -7);
    updateUI();
  }

  function updateUI(){ scoreEl.textContent=state.score; livesEl.textContent=state.lives; levelEl.textContent=state.level; ballsEl.textContent=state.balls;}

  let last = 0;
  function loop(ts){
    if(!state.running) return;
    frames++;
    if(state.paused){ requestAnimationFrame(loop); return; }
    const dt = Math.min(40, ts - last); last = ts;
    step(dt/16.6667);
    render();
    requestAnimationFrame(loop);
  }

  // ============================================
  // STEP FUNCTION (REFORMATTED FOR PERFORMANCE)
  // ============================================
  function step(delta){
    // --- Paddle Update ---
    if(keys['ArrowLeft'] || keys['a']) paddle.x -= paddle.speed * delta;
    if(keys['ArrowRight'] || keys['d']) paddle.x += paddle.speed * delta;
    paddle.x = Math.max(6, Math.min(W - paddle.w - 6, paddle.x));

    if(paddle.cooldown > 0) paddle.cooldown -= delta;
    if(paddle.invincibleTimer > 0) paddle.invincibleTimer -= delta;

    if(keys[' '] && balls.some(b => b.stuck)){
        for(const b of balls) if(b.stuck){ b.stuck=false; b.dx=rand(-3,3); b.dy=-8; beep(780,0.04,'square',0.06); }
    }
    if((keys['x']||keys['X']) && paddle.cooldown <= 0){
        playerBullets.push({x:paddle.x+paddle.w/2-2, y:paddle.y-8, w:4, h:8, vy:-8});
        paddle.cooldown = 16;
        beep(1200,0.03,'sine',0.04);
    }

    // --- Ball Update ---
    for(let i = balls.length-1; i >= 0; i--){
        const b = balls[i];
        if(b.stuck){ b.x = paddle.x + paddle.w/2; b.y = paddle.y-12; continue; }

        b.x += b.dx * delta;
        b.y += b.dy * delta;
        b.dy += 0.08 * delta;

        if(b.x-b.r < 6 || b.x+b.r > W-6){ b.dx *= -1; beep(600,0.02,'sine',0.04); }
        if(b.y-b.r < 6){ b.dy *= -1; beep(600,0.02,'sine',0.04); }

        if(b.y-b.r > H){
            balls.splice(i,1);
            if(balls.length===0){
                state.lives--;
                updateUI();
                beep(180,0.2,'sine',0.12);
                if(state.lives>0) spawnBall(paddle.x+paddle.w/2,paddle.y-12,0,-4);
                else { state.running=false; alert('Game Over — Score: '+state.score); }
            }
        }
        
        if(b.y+b.r > paddle.y && b.y-b.r < paddle.y+paddle.h && b.x+b.r > paddle.x && b.x-b.r < paddle.x+paddle.w){
            const pct = (b.x-paddle.x)/paddle.w;
            const angle = (pct-0.5)*Math.PI/1.8;
            const speed = Math.min(12,Math.hypot(b.dx,b.dy));
            b.dx = Math.sin(angle)*speed;
            b.dy = -Math.abs(Math.cos(angle)*speed);
            b.y = paddle.y-b.r-1;
            beep(900,0.02,'square',0.06);
        }
      
        for(let j = bricks.length-1; j >= 0; j--){
            const br = bricks[j];
            const ballRect = {x:b.x-b.r, y:b.y-b.r, w:b.r*2, h:b.r*2};
            if(rectIntersect(ballRect,br)){
                b.dy *= -1;
                br.health--;
                spawnParticles(b.x,b.y,'rgba(200,255,200,0.9)',12);
                if(br.health <= 0){
                    state.score += 100;
                    if(Math.random()<0.05) spawnPowerUp(br.x+br.w/2,br.y,'life');
                    else if(Math.random()<0.08) spawnPowerUp(br.x+br.w/2,br.y,'shield');
                    else if(Math.random()<0.12) { state.balls++; spawnBall(br.x+br.w/2,br.y,rand(-3,3),-4); }
                    if(Math.random()<0.35) spawnCoin(br.x+br.w/2,br.y);
                    bricks.splice(j,1);
                    beep(1500,0.06,'triangle',0.08);
                } else {
                    state.score += 20;
                    beep(900,0.03,'sine',0.05);
                }
                updateUI();
                break;
            }
        }
    }

    // --- Enemy Bricks Update ---
    if(bricks.length > 0){
        let minX=Infinity, maxX=-Infinity;
        for(const br of bricks){ minX=Math.min(minX,br.x); maxX=Math.max(maxX,br.x+br.w); }
        let groupDir = (maxX>=W-12)?-1:(minX<=12?1:0);
        for(const br of bricks){
            br.x += br.vx * (groupDir || br.dir) * 0.45 * delta;
            br.cooldown -= delta;
            if(br.cooldown < 0 && Math.random() < levelSettings.enemyFireRate){
                enemyBullets.push({x:br.x+br.w/2-3, y:br.y+br.h+2, w:6, h:10, vy:levelSettings.enemyBulletSpeed});
                br.cooldown = rand(120,420);
            }
        }
    }

    // --- Bullets Update ---
    for(let i=enemyBullets.length-1; i>=0; i--){
        const e = enemyBullets[i];
        e.y += e.vy * delta;
        if(e.y > H) {
            enemyBullets.splice(i,1);
        } else if(rectIntersect(e,paddle)){
            if(paddle.invincibleTimer <= 0){
                paddle.shield--;
                spawnParticles(e.x,e.y,'rgba(255,200,100,0.9)',20);
                if(paddle.shield < 0){
                    state.lives--;
                    beep(160,0.2,'sawtooth',0.12);
                    if(state.lives <= 0){ state.running=false; alert('Game Over'); }
                    else { paddle.shield=paddle.maxShield; }
                } else {
                    beep(220,0.08,'square',0.09);
                }
                paddle.invincibleTimer = 90;
            }
            enemyBullets.splice(i,1);
            updateUI();
        }
    }
    for(let i=playerBullets.length-1; i>=0; i--){
        const pb = playerBullets[i];
        pb.y += pb.vy*delta;
        if(pb.y < -20) {
            playerBullets.splice(i,1);
        } else {
            for(let j=bricks.length-1; j>=0; j--){
                const br = bricks[j];
                if(rectIntersect(pb,br)){
                    playerBullets.splice(i,1);
                    br.health--;
                    spawnParticles(br.x+br.w/2,br.y+br.h/2,'rgba(200,255,200,0.9)',8);
                    if(br.health<=0){ state.score+=100; bricks.splice(j,1); }
                    updateUI();
                    break;
                }
            }
        }
    }
    
    // --- Collectibles Update ---
    for(let i=powerUps.length-1; i>=0; i--){
        const p = powerUps[i];
        p.y += p.vy * delta;
        if(rectIntersect(p,paddle)){
            if(p.type==='shield'){ paddle.shield = Math.min(paddle.maxShield, paddle.shield+1); }
            else if(p.type==='life'){ state.lives = Math.min(5, state.lives+1); updateUI(); }
            beep(1800,0.1,'triangle',0.1);
            powerUps.splice(i,1);
        } else if(p.y > H) {
            powerUps.splice(i,1);
        }
    }
    for(let i=coins.length-1; i>=0; i--){
        const c = coins[i];
        c.y += c.vy * delta;
        const coinRect = {x:c.x-c.r, y:c.y-c.r, w:c.r*2, h:c.r*2};
        if(rectIntersect(coinRect, paddle)){
            state.score += 50;
            updateUI();
            beep(1000,0.05,'sine',0.1);
            coins.splice(i,1);
        } else if(c.y > H) {
            coins.splice(i,1);
        }
    }
    
    // --- Final Updates ---
    updateParticles();
    if(bricks.length === 0){
        state.level++;
        state.balls=1;
        state.score+=1000;
        reset(); // Use reset without full=true to keep score
        beep(600,0.4,'sawtooth',0.1);
    }
  }

  function render(){
    ctx.fillStyle=levelSettings.bgColor; ctx.fillRect(0,0,W,H);
    for(let i=0;i<40;i++){ctx.fillStyle='rgba(255,255,255,'+(i%7===0?0.06:0.02)+')';const sx=(i*73+(performance.now()/20)%W)%W;ctx.fillRect(sx,(i*37)%H,1,1);}

    for(const br of bricks){
        const g=ctx.createLinearGradient(br.x,br.y,br.x+br.w,br.y+br.h);
        if (br.maxHealth > 2) {
            const healthPct = br.health / br.maxHealth;
            g.addColorStop(0, `rgb(${192 + 63 * healthPct}, ${192 + 63 * healthPct}, ${192 + 63 * healthPct})`);
            g.addColorStop(1, '#c0c0c0');
        } else {
            g.addColorStop(0,br.health>1?'#ffd6d6':'#ff6b6b'); g.addColorStop(1,'#ff3b3b');
        }
        ctx.fillStyle=g; ctx.fillRect(br.x,br.y,br.w,br.h);
        ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.strokeRect(br.x,br.y,br.w,br.h);
    }
    
    if(paddle.invincibleTimer>0&&Math.floor(paddle.invincibleTimer/6)%2===0) ctx.globalAlpha=0.5;
    ctx.fillStyle=paddle.color; roundRect(ctx,paddle.x,paddle.y,paddle.w,paddle.h,8); ctx.fill();
    ctx.globalAlpha=1.0;
    if(paddle.shield>=0){const shieldWidth=(paddle.w/paddle.maxShield)*paddle.shield;ctx.fillStyle='rgba(100,255,255,0.8)';ctx.strokeStyle='rgba(255,255,255,0.9)';ctx.lineWidth=1;roundRect(ctx,paddle.x,paddle.y-10,paddle.w,5,3);ctx.stroke();roundRect(ctx,paddle.x,paddle.y-10,shieldWidth,5,3);ctx.fill();}
    
    for(const c of coins){ctx.beginPath();ctx.fillStyle='gold';ctx.arc(c.x,c.y,c.r,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.fillStyle='orange';ctx.arc(c.x,c.y,c.r*0.6,0,Math.PI*2);ctx.fill();}
    for(const p of powerUps){
        if (p.type === 'life') {
            ctx.fillStyle = '#ff8888'; // Red for life
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = 'white'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('♥', p.x + 3, p.y + 14);
        } else { // Shield
            ctx.fillStyle = '#88ff88'; // Green for shield
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = 'black'; ctx.font = 'bold 12px sans-serif'; ctx.fillText('S', p.x + 5, p.y + 13);
        }
    }

    for(const b of balls){ctx.beginPath();ctx.fillStyle='white';ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();ctx.closePath();}
    ctx.fillStyle='#ffef99';for(const eb of enemyBullets)roundRect(ctx,eb.x,eb.y,eb.w,eb.h,4),ctx.fill();
    ctx.fillStyle='#99ffff';for(const pb of playerBullets)roundRect(ctx,pb.x,pb.y,pb.w,pb.h,2),ctx.fill();
    drawParticles();
  }

  function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();}
  
  startBtn.onclick=()=>{if(!state.running){state.running=true;state.paused=false;last=performance.now();reset(true);requestAnimationFrame(loop);}else{state.paused=false;}};
  pauseBtn.onclick=()=>{state.paused=!state.paused;pauseBtn.textContent=state.paused?'Resume':'Pause';};
  resetBtn.onclick=()=>{reset(true);};
  
  reset(true);
  window.addEventListener('click',()=>{if(audioCtx.state==='suspended')audioCtx.resume();},{once:true});
  </script>
</body>
</html>